\documentclass{report}
\usepackage{color}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\usepackage[margin=1.2in]{geometry}
\usepackage{rotating}
\usepackage[utf8]{inputenc}
\usepackage{multirow}
\usepackage[table,xcdraw]{xcolor}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{tabularx} 
\usepackage{tabulary}
\usepackage{cutwin}
\usepackage{caption}
\usepackage{lipsum}
\usepackage{wrapfig}
\usepackage{color}
\usepackage{eurosym}
%\usepackage{glossaries}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{titlesec}
\usepackage{enumerate}
\usepackage{listings}

\newenvironment{abbreviations}{\begin{list}{}{\renewcommand{\makelabel}{\abbrlabel}}}{\end{list}}
\newcommand{\abbrlabel}[1]{\makebox[3cm][l]{\textbf{#1}\ \dotfill}}

\begin{document}
	
\begin{titlepage}
	\centering
	\vspace*{0.5 cm}
	\includegraphics[scale = 0.75]{Images/umee}\\[1.0 cm]
	\textsc{\LARGE University of Minho}\\[2.0 cm]
	\textsc{\Large Project II}\\[0.5 cm]		
	\textsc{\large Integrated Master in Electronics and Computer Engineering}\\[0.5 cm]				% Course Name
	\rule{\linewidth}{0.2 mm} \\[0.4 cm]
		{ \huge \bfseries Final Report} \\
        { \huge \bfseries Modeling for Dynamic Binary Translation \\
			\LARGE \bfseries Code Generation}
		
	\rule{\linewidth}{0.2 mm} \\[1.5 cm]
		
		\begin{minipage}{0.4\textwidth}
			\begin{flushleft} \large
				\emph{Authors:}\\
				Ana Rita Fernandes Martins\\
				David Miguel Parente Almeida
			\end{flushleft}
		\end{minipage}~
		\begin{minipage}{0.4\textwidth}
			\begin{flushright} \large
				\emph{Number:} \\
				64734 \\
				68532
			\end{flushright}
		\end{minipage}\\[2 cm]
		
	{\large GuimarÃ£es, \today }\\[2 cm]
		
	\vfill
	
\pagenumbering{gobble}
\end{titlepage}
	
\newpage

%-------------------------------------------
\pagenumbering{roman}  
\tableofcontents
\newpage
%-------------------------------------------	
\listoffigures
\newpage
%-------------------------------------------	
\listoftables
\newpage
%-------------------------------------------	
\section*{Abbreviations}
%please put in alfabetical order
\begin{abbreviations} 
	\item[DBT] Dynamic Binary Translator
	\item[DSL] Domain Specific Language
	\item[EL] Elaboration Language
	\item[ISA] Instruction Set Architecture
	\item[XML] eXtensible Markup Language
\end{abbreviations}
\newpage
%-------------------------------------------	
\pagenumbering{arabic}
%START ABSTRACT CHAPTER
\chapter{Abstract}

\par Creating a model for a embedded system provides a time-saving and cost-effective approach to the development of dynamic systems, based on a single model maintained in a tightly integrated software. 
\par Using modern modeling software tools it is possible to design and perform initial validation. It is possible to reduce the risk of errors and shorten development time by performing verification and validation testing throughout the development. Errors and overhead can also be reduced through the use of automatic code generation techniques\cite{modelling-embsys}.
%END ABSTRACT CHAPTER
%-------------------------------------------
%START ANALYSIS CHAPTER
\chapter{Analysis}

	\section{Motivation}
	
	\par Let's write this in the end.

	\section{Objectives}
	
	\par The objectives of this work are:
	\begin{itemize}
		\item Identifying the modules for the reference architecture;
		\item Modeling the implementation of a DBT;
		\item etc
	\end{itemize}

	\section{Problem Statement}
	
	\par Modeling is used in order to automate the configuration and generation of the final system. To create a model it is necessary a specialized framework, and the one used in this project was developed together with all the groups in the context of the major in Embedded Systems, consisting on a Domain Specific Language (DSL) which purpose is to model reference architectures and make its respective code generation. 
	\par In this particular case, the modeling framework is used with the objective to model a DBT, in which the source code follows a 8051 Instruction Srt Architecture (ISA) and the translated code is generated for a ARMv7-M ISA.  The reference architecture was agreed by all the groups that are into this project, and this group focus is on the code generation for the target architecture and code optimization.
	
	\begin{figure} [h]
		\centering
		\includegraphics[width=0.7\linewidth]{Images/DSL_use_cases}
		\caption{Compilation phases.}
		\label{fig:compiler-sequence}
	\end{figure}
	

	\par 
	\section{State Of The Art}

	\par OpenMETA

	\section{Modeling Languages}
	%START > WIKIPEDIA
	\par A modeling language is any artificial language that can be used to express information or knowledge or systems in a structure that is defined by a consistent set of rules. The rules are used for interpretation of the meaning of components in the structure.
	
	\par A modeling language can be graphical or textual.[1]
	
	Graphical modeling languages use a diagram technique with named symbols that represent concepts and lines that connect the symbols and represent relationships and various other graphical notation to represent constraints.
	Textual modeling languages may use standardized keywords accompanied by parameters or natural language terms and phrases to make computer-interpretable expressions.
	An example of a graphical modeling language and a corresponding textual modeling language is EXPRESS.
	
	Not all modeling languages are executable, and for those that are, the use of them doesn't necessarily mean that programmers are no longer required. On the contrary, executable modeling languages are intended to amplify the productivity of skilled programmers, so that they can address more challenging problems, such as parallel computing and distributed systems.
	
	A large number of modeling languages appear in the literature.
	%END
		
		\subsection{Domain Specific Languages}
		
		\par DSL are programming languages, commonly with a small set of expressions, with the objective of abstracting and simplifying the code written for a specific case. So, these languages are useful just when used in that specific situation. Tough they may look limited at a first glance, they may have all the necessary resources to write code for a determined domain.
		\par The usage of these languages should be simple enough in a way that the model is be the biggest effort done. A model should also be translated into code very intuitively by the user. It is important to note that the user is not always a designer: a DSL should be clear at the point that someone who is not used to programming languages could create its script without a lot of effort. The simplicity is pointed as a advantage, but there are disadvantages too: creating a framework like this requires a lot of technical skills and knowledge, and the development is very time consuming.
		\par To write a DSL it is necessary to gather all the requirements to avoid subjectiveness and to specify all the semantics. Then, it is written a set of grammatic rules that check the desired operation of the language. It is also important to implement software capable of validate the code, type checking and scoping.
		\par After writing all of this software, it is necessary to implement engines that provide code generation. If the code generation is done nicely, the resulting behavioral model is correct.
		
		\subsection{Service Component Architecture}
		%WRITE ABOUT SCA HERE
		\par 
		
		\paragraph{Elaboration Language Context} EL is based on the SCA. Next it is presented every element that can be used and a brief description.
		
			\subparagraph{Composite} A composite is a set of components. These can be used to represent another components or a reference architecture.
		
			\subparagraph{Component} An entity that provides or references services. 
		
			\subparagraph{Property} Variables that can be defined inside the component and that store its characteristics. 
		
			\subparagraph{Interface} A list of functions that describe a service or reference.
		
			\subparagraph{Service} Set of operations associated to a component are characterized by an interface. 
		
			\subparagraph{Reference} A service that is consumed by a component. Also characterized by an interface.
		
			\subparagraph{Wire} A bound created between a reference and a service defined by the same interface.
		
			\subparagraph{Implementation} Code block implemented in a programming language.
		
		\subsection{Elaboration Language}
		
		\par Elaboration Language (EL) was the DSL developed by a group of students to create models, and was written using the Eclipse frameworks Xtext and Xtend. Xtext is necessary for specifying the grammar and all the other features were written using Xtend. 
		\par EL follows the Service Component Architecture specification in which everything is composed by components. The components are related through services and references to that services. 
		\par It is necessary to follow a work flow when using this DSL to create the necessary artifacts. Next the correct work flow is explained.

			\subsubsection{Work Flow}
		
			\par To develop and use a reference architecture there must be followed a work flow, composed by four steps: modeling, elaboration, configuration and generation. Each step provides the artifacts necessary for the subjacent step.
		
			\paragraph{Modeling} The first step consists in designing the reference architecture and, after that, writing the respective EL scripts. In some cases it is necessary to make code refactoring to keep the code in concordance with the model. It is also necessary to annotate the source files so the elaborations can replace these same annotations for literal values or expressions.

			\paragraph{Elaboration} In this step are constructed Java classes to alter the code with annotations provided by the user. After the system modeling and writing all the elaboration, it is created a Java program called \textbf{Elaborator}. This program understands the complete model.

			\paragraph{Configuration} At compilation time there are generated XML files with the configuration of the reference architecture components. The User can alter these files and by that configure properties values, arrays sizes ou change which elaboration will modify the source code.

			\paragraph{Generation} After completing all the steps above, the User can execute the Elaborator and generate the new source code. The Elaborator uses all the elaborations necessary to create the code.
			
			\subsubsection{Syntax and Semantics}

			\subsubsection{Use Cases}

			\subsubsection{Example}

	\section{Dynamic Binary Translator}
		%START > TAKEN FROM SLIDES
		\par A Dynamic Binary Translator (DBT) allows the execution of the binary code from one architecture to a different one. It is used for emulation, migration, and recently for the economic implementation of complex ISAs [1].
		
		\par Translation can be done in hardware (for example, by circuits in a CPU) or in software (e.g. run-time engines, statical recompiler, emulators) [2].
		%END


		\subsection{Source Architecture: Intel MCS-51}
		
		\subsection{Target Architecure: ARMv7-M}
		\subsection{Application Scenario}

	\section{Resources}

		\subsection{Hardware}

			\paragraph{placa do Filipe}

		\subsection{Software}

			\paragraph{Understand}

			\paragraph{IAR}

	\section{Block Diagram}

	\section{Implementation Plan}

%END ANALYSIS CHAPTER
%-------------------------------------------
%START DESIGN CHAPTER

\chapter{Design}

	\section{Reference Architecture}

		\subsection{Generation}

		\subsection{Optimization}

	\section{Test Plans}
	
%END DESIGN CHAPTER
%-------------------------------------------
%START IMPLEMENTATION CHAPTER

\chapter{Implementation Phase}

	\section{Reference Architecture}

	\section{Code Refactoring}

	\section{Code Generation}

	\section{Optimization}
	
	\section{Elaborations}
	
	\section{Elaboration Language Script}

%END CONCEPTION CHAPTER
%-------------------------------------------
%START CONCLUSION CHAPTER

\chapter{Conclusion}

	\section{Future Work}

%END CONCLUSION CHAPTER
%-------------------------------------------
\newpage
	
\begin{thebibliography} {9}
	
	\bibitem{modelling-embsys} Embedded, "Modeling of embedded designs - Part 1: Why model?". [Online]. Available: http://www.embedded.com/design/prototyping-and-development/4399743/Modeling-of-embedded-designs--Why-model--
			
\end{thebibliography}
	
\end{document}