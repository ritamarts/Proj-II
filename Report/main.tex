\documentclass{report}
\usepackage{color}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\usepackage[margin=1.2in]{geometry}
\usepackage{rotating}
\usepackage[utf8]{inputenc}
\usepackage{multirow}
\usepackage[table,xcdraw]{xcolor}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{tabularx} 
\usepackage{tabulary}
\usepackage{cutwin}
\usepackage{caption}
\usepackage{lipsum}
\usepackage{wrapfig}
\usepackage{color}
\usepackage{eurosym}
%\usepackage{glossaries}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{titlesec}
\usepackage{enumerate}
\usepackage{listings}
%\usepackage{filecontents}
\usepackage{cite}
\usepackage{float}

\newenvironment{abbreviations}{\begin{list}{}{\renewcommand{\makelabel}{\abbrlabel}}}{\end{list}}
\newcommand{\abbrlabel}[1]{\makebox[3cm][l]{\textbf{#1}\ \dotfill}}

\titleclass{\subsubsubsection}{straight}[\subsection]
\newcounter{subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection.\arabic{subsubsubsection}}
\renewcommand\theparagraph{\thesubsubsubsection.\arabic{paragraph}} % optional; useful if paragraphs are to be numbered
\titleformat{\subsubsubsection}
{\normalfont\normalsize\bfseries}{\thesubsubsubsection}{1em}{}
\titlespacing*{\subsubsubsection}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{5}{\z@}%
	{3.25ex \@plus1ex \@minus.2ex}%
	{-1em}%
	{\normalfont\normalsize\bfseries}}
\renewcommand\subparagraph{\@startsection{subparagraph}{6}{\parindent}%
	{3.25ex \@plus1ex \@minus .2ex}%
	{-1em}%
	{\normalfont\normalsize\bfseries}}
\def\toclevel@subsubsubsection{4}
\def\toclevel@paragraph{5}
\def\toclevel@paragraph{6}
\def\l@subsubsubsection{\@dottedtocline{4}{7em}{4em}}
\def\l@paragraph{\@dottedtocline{5}{10em}{5em}}
\def\l@subparagraph{\@dottedtocline{6}{14em}{6em}}
\makeatother
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}


\begin{document}
	
\begin{titlepage}
	\centering
	\vspace*{0.5 cm}
	\includegraphics[scale = 0.75]{Images/umee}\\[1.0 cm]
	\textsc{\LARGE University of Minho}\\[2.0 cm]
	\textsc{\Large Project II}\\[0.5 cm]		
	\textsc{\large Integrated Master in Electronics and Computer Engineering}\\[0.5 cm]				% Course Name
	\rule{\linewidth}{0.2 mm} \\[0.4 cm]
		{ \huge \bfseries Final Report} \\
        { \huge \bfseries Modeling for Dynamic Binary Translation \\
			\LARGE \bfseries Code Generation}
		
	\rule{\linewidth}{0.2 mm} \\[1.5 cm]
		
		\begin{minipage}{0.4\textwidth}
			\begin{flushleft} \large
				\emph{Authors:}\\
				Ana Rita Fernandes Martins\\
				David Miguel Parente Almeida
			\end{flushleft}
		\end{minipage}~
		\begin{minipage}{0.4\textwidth}
			\begin{flushright} \large
				\emph{Number:} \\
				64734 \\
				68532
			\end{flushright}
		\end{minipage}\\[2 cm]
		
	{\large Guimar√£es, \today }\\[2 cm]
		
	\vfill
	
\pagenumbering{gobble}
\end{titlepage}
	
\newpage

%-------------------------------------------
\pagenumbering{roman}  
\tableofcontents
\newpage
%-------------------------------------------	
\listoffigures
\newpage
%-------------------------------------------	
\listoftables
\newpage
%-------------------------------------------	
\section*{Abbreviations}
%please put in alfabetical order
\begin{abbreviations} 
	\item[CC] Condition Codes
	\item[CPU] Control Processing Unit
	\item[DBT] Dynamic Binary Translation
	\item[DSL] Domain Specific Language
	\item[EL] Elaboration Language
	\item[ISA] Instruction Set Architecture
	\item[LR] Link Register
	\item[PC] Program Counter
	\item[SCA] Service Component Architecture
	\item[SFR] Special Function Registers
	\item[SP] Stack Pointer
	\item[XML] eXtensible Markup Language
\end{abbreviations}
\newpage
%-------------------------------------------	
\pagenumbering{arabic}
%START ABSTRACT CHAPTER
\chapter{Abstract}

\par Creating a model for a embedded system provides a time-saving and cost-effective approach to the development of dynamic systems, based on a single model maintained in a tightly integrated software. 
\par Using modern modeling software tools it is possible to design and perform initial validation. It is possible to reduce the risk of errors and shorten development time by performing verification and validation testing throughout the development. Errors and overhead can also be reduced through the use of automatic code generation techniques\cite{j.h.foleissa.l.t.d'amatoa.f.dasilva2012}.

\par THIS IS NOT GOOD YET
%END ABSTRACT CHAPTER
%-------------------------------------------
%START ANALYSIS CHAPTER
\chapter{Analysis}

	\section{Motivation}
	
	\par Let's write this in the end.

	\section{Objectives}
	
	\par The objectives of this work are:
	\begin{itemize}
		\item Identifying the modules for the reference architecture;
		\item Modeling the implementation of a DBT;
		\item etc
	\end{itemize}

	\section{Problem Statement}
	
	\par Modeling is used in order to automate the configuration and generation of the final system. To create a model it is necessary a specialized framework, and the one used in this project was developed together with all the groups in the context of the major in Embedded Systems, consisting on a Domain Specific Language (DSL) which purpose is to model reference architectures and make its respective code generation. 
	\par In this particular case, the modeling framework is used with the objective to model a DBT, in which the source code follows a 8051 Instruction Srt Architecture (ISA) and the translated code is generated for a ARMv7-M ISA.  The reference architecture was agreed by all the groups that are into this project, and this group focus is on the code generation for the target architecture and code optimization.
	
	\begin{figure} [H]
		\centering
		\includegraphics[width=0.7\linewidth]{Images/DSL_use_cases}
		\caption{Compilation phases.}
		\label{fig:compiler-sequence}
	\end{figure}

	\section{Modeling Languages}
	\par A modeling language is any artificial language that can be used to express information or knowledge or systems in a structure that is defined by a consistent set of rules. The rules are used for interpretation of the meaning of components in the structure. They can be graphical or textual.
	\par Graphical modeling languages use a diagram technique with named symbols that represent concepts and lines that connect the symbols and represent relationships and various other graphical notation to represent constraints.
	\par Textual modeling languages may use standardized keywords accompanied by parameters or natural language terms and phrases to make computer-interpretable expressions.
	\par Not all modeling languages are executable, and for those that are, the use of them does not necessarily mean that programmers are no longer required. On the contrary, executable modeling languages are intended to amplify the productivity of skilled programmers, so that they can address more challenging problems, such as parallel computing and distributed systems\cite{wikipedia}.
		
		\subsection{Domain Specific Languages}
		
		\par DSL are programming languages, commonly with a small set of expressions, with the objective of abstracting and simplifying the code written for a specific case. So, these languages are useful just when used in that specific situation. Tough they may look limited at a first glance, they may have all the necessary resources to write code for a determined domain.
		\par The usage of these languages should be simple enough in a way that the model is be the biggest effort done. A model should also be translated into code very intuitively by the user. It is important to note that the user is not always a designer: a DSL should be clear at the point that someone who is not used to programming languages could create its script without a lot of effort. The simplicity is pointed as a advantage, but there are disadvantages too: creating a framework like this requires a lot of technical skills and knowledge, and the development is very time consuming.
		\par To write a DSL it is necessary to gather all the requirements to avoid subjectiveness and to specify all the semantics. Then, it is written a set of grammatic rules that check the desired operation of the language. It is also important to implement software capable of validate the code, type checking and scoping.
		\par After writing all of this software, it is necessary to implement engines that provide code generation. If the code generation is done nicely, the resulting behavioral model is correct.
		
		\subsection{Service Component Architecture}
		
		\par Service Component Architecture (SCA) is a programming model for abstracting functions as components and using them as building blocks to assemble solutions. A component offers services and depends on functions that are called references.
		\par SCA provides a declarative way to describe how the services interact with one another. Since service interaction is declarative, solution developers remain focus on logic and therefore development cycle is simplified and shortened. This also promotes the development of reusable services that can be used in different contexts. For example, a shopping cart service can be used in a retail application or a travel application without changing. Services can interact with one another synchronously or asynchronously and can be implemented in any technology.
		\par SCA also brings flexibility to deployment. A solution assembled with SCA is deployed as a unit and can be distributed over one or more nodes in the network and can be reconfigured without programming changes \cite{apachetuscany}.
	
		\begin{figure} [H]
			\centering
			\includegraphics[width=0.8\linewidth]{Images/sca}
			\caption{SCA model example\cite{theenterprisearchitect}.}
			\label{fig:sca}
		\end{figure}
		
		\paragraph{Elaboration Language Context} EL is based on the SCA. Next it is presented every element that can be used and a brief description.
		
			\subparagraph{Composite} A composite is a set of components. These can be used to represent another components or a reference architecture.
		
			\subparagraph{Component} An entity that provides or references services. 
		
			\subparagraph{Property} Variables that can be defined inside the component and that store its characteristics. 
		
			\subparagraph{Interface} A list of functions that describe a service or reference.
		
			\subparagraph{Service} Set of operations associated to a component are characterized by an interface. 
		
			\subparagraph{Reference} A service that is consumed by a component. Also characterized by an interface.
		
			\subparagraph{Wire} A bound created between a reference and a service defined by the same interface.
		
			\subparagraph{Implementation} Code block implemented in a programming language.
		
		\subsection{Elaboration Language}
		
		\par Elaboration Language (EL) was the DSL developed by a group of students to create models, and was written using the Eclipse frameworks Xtext and Xtend. Xtext is necessary for specifying the grammar and all the other features were written using Xtend. 
		\par EL follows the Service Component Architecture specification in which everything is composed by components. The components are related through services and references to that services. 
		\par It is necessary to follow a work flow when using this DSL to create the necessary artifacts. Next the correct work flow is explained.

			\subsubsection{Work Flow}
		
			\par To develop and use a reference architecture there must be followed a work flow, composed by four steps: modeling, elaboration, configuration and generation. Each step provides the artifacts necessary for the subjacent step.
			
			\begin{figure} [H]
				\centering
				\includegraphics[width=1\linewidth]{Images/workflow}
				\caption{EL Workflow.}
				\label{fig:workflow}
			\end{figure}
		
			\paragraph{Modeling} The first step consists in designing the reference architecture and, after that, writing the respective EL scripts. In some cases it is necessary to make code refactoring to keep the code in concordance with the model. It is also necessary to annotate the source files so the elaborations can replace these same annotations for literal values or expressions.

			\paragraph{Elaboration} In this step are constructed Java classes to alter the code with annotations provided by the user. After the system modeling and writing all the elaboration, it is created a Java program called \textbf{Elaborator}. This program understands the complete model.

			\paragraph{Configuration} At compilation time there are generated XML files with the configuration of the reference architecture components. The User can alter these files and by that configure properties values, arrays sizes ou change which elaboration will modify the source code.

			\paragraph{Generation} After completing all the steps above, the User can execute the Elaborator and generate the new source code. The Elaborator uses all the elaborations necessary to create the code.
			
			\subsubsection{Syntax and Semantics}
			
			\par It is essential to any language to be easily understandable. In the EL context it is necessary to understand how is it possible to express the service-based models.
			\par To a better understanding it is exposed a simple model with two components in which one offers a service to another, represented in figure \ref{fig:example-diagram}.
			
			\begin{figure} [H]
				\centering
				\includegraphics[width=0.5\linewidth]{Images/diagram}
				\caption{Example diagram.}
				\label{fig:example-diagram}
			\end{figure}
			
			\par The example diagram shows an EL model, in which the \texttt{Composite} is the component from where the model is generated. In the code this is represented by the expression \texttt{compile Composite}. It is defined a \texttt{language} and both components should follow it. In the \texttt{language} definition it is indicated the annotation symbol to be used by the elaborations later. An \texttt{interface} is created with all the functions that component \texttt{C\_B} provides as services. The component \texttt{C\_A} has one property \texttt{P\_A} of the type \texttt{int} and one reference \texttt{R\_A} to the service of the other component, so this reference must follow the same interface as the respective service from \texttt{C\_B}. The component \texttt{C\_B} offers a service \texttt{S\_B} and has a property \texttt{P\_B} of the type \texttt{string} with the default value text. Finally it is declared the component \texttt{Composite} that contains the two components described above and the \texttt{bind} of the reference \texttt{R\_A} to the service \texttt{S\_B}.
			
			\begin{lstlisting}
			compile Composite
			
			language C{
				annotation: "@"
			}
			
			interface Interface {
				func1 func2
			}
			
			component C_A (C) {
				properties:
					int P_A
				references:
					Interface R_A
			}
			
			component C_B (C) {
				properties:
					string P_B : "text"
				services:
					Interface S_B
			}
			
			component Composite (C) {
				subcomponents:
					C_A a
					C_B b
				
				bind a.R_A to b.S_B
			}
			\end{lstlisting} 

			\subsubsection{Use Cases}
			
			\par Two actors, the designer and the user, can interact with the languages artifacts. The user differentiates
			from the designer to the extent that not possess the technical skills to design a reference architecture.
			\par The \textbf{designer} is responsible for writing the elaboration files and the EL model design. The \textbf{user} is only responsible for the configuration of properties, if they exist and the Elaborator execution.
			
			\begin{figure} [H]
				\centering
				\includegraphics[width=0.4\linewidth]{Images/use-cases}
				\caption{Example diagram.}
				\label{fig:use-cases}
			\end{figure}			
			

	\section{Dynamic Binary Translation}
	\par Binary translation is the process of converting code for one ISA architecture to code for another. There are two types of binary translation: static and dynamic. The main difference between the two approaches is that the static translation translates the entire program before the execution and dynamic translation translates code on demand. This allows the dynamic binary translation (DBT) to deal with challenges that static binary translation do not suffice \cite{b.hawkingsb.demskyd.brueningq.zhao2015}. 
	\par In this project was used a dynamic binary translation to create the model. It translates one basic block at a time and then executes it. The translated code, as well as the source code, is cached so if one basic block is stored into the translation cache, the cache returns an hit and it is not necessary to translate it again. 
	\par In this program, it was used the Intel MCS-51, also known as 8051, as the source architecture and the ARMv7-M as the target architecture. After the code refactoring, it is possible to change the source and target architecture. Although, the translation algorithm will need to be rewritten to adapt to the target architecture needs.
	
		\subsection{Source Architecture: Intel MCS-51}
		
		\par The Intel MCS-51, also known as 8051, is part of a family of 8-bit microcontrollers family developed by Intel in the '80s. It is known for being ease of programming so it is used in large scale for small projects and to instruct students. By being a Complex Instruction Set Computer (CISC) microcontroller, it offers a large set of instructions. These characteristics make it the most popular microcontroller.
		\par The 8051 only offers one memory, divided into two separated addressing spaces to data and programs. In the data memory, the inferior block is divided into three parts: the registers bank, the bit addressable area and the draft area.
		\par The Control Processing Unit (CPU) Special Function Registers (SFR) , with exception of the Program Counter (PC), are allocated into the superior part of the intern data memory.  They are:
		\begin{itemize}
			\item ACC - Acumulator.
			\item B - Used as source and target register to division and multiplication operations.
			\item Stack Pointer (SP) - Pointer to the CPU stack.
			\item Data Pointer (DPTR) - 16-bits register used to address the external data memory. Uses two bytes, the DPL (Data Pointer Low) and DPH (Data Pointer High).
			\item P0, P1, P2, P3 - Used to latch the I/o ports.
			\item Serial Data Buffer (SBUF) - Use to transmission and reception in the serial port.
			\item Program Status Word (PSW) - Contains the CPU flags.
			\item Timer Registers - The 8051 offers three timers and each has two 8-bit registers to configure. The Timer 0 uses TH0 and TL0, Timer 1 uses and TH1 and TL1 and Timer 2 uses TH2 and TL2.
			\item Capture Registers (RCAP2H, RCAP2L) - Used by Timer 2 for the capture mode.
			\item Control Registers - IP, IE, TMOD, RCON, SCON, PCON are control resisters used by the interruption system from serial port and timing sections. 
		\end{itemize}
		
		\par It is important to note that at the time, the translation algorithm only provides a emulation of the ACC, B, SP and DPTR registers.
		\par The 8051 offers five groups of instructions: arithmetic, branch, data transfer, logic and bit-oriented. Arithmetic instructions perform several tasks such as addition, subtraction, division and multiplication. Branch instructions can perform conditional and unconditional jumps. The main difference between them is that conditional jumps rely on the condition codes to verify if the branch is taken or not. Data transfer instructions move the content of one register to another. Logic instructions perform logic operations upon corresponding bits of two registers. Bit-oriented instructions are logic operations perform upon single bits\cite{mikroelektronika}.
		\par The instructions size and format vary from 1 to 3 bytes to achieve the desired output. Even the same operation may vary in instruction size depending on the operands. Looking at the addition operation (\texttt{ADD}) case, when it is desired to add an immediate value to the accumulator (\texttt{ADD A, \#immediate}), 2 bytes are used. When it is desired to add the content of a register to the accumulator (\texttt{ADD A, Rn}), only 1 byte is used. This also means that the PC will be computed differently in accordance with the instruction size.
		
		\subsection{Target Architecture: ARMv7-M}
		
		\par 
		
			\subsubsection{Thumb-2}
			
	\subsection{Architectural Model}
	
	\par Figure \ref{fig:block} represents the model of the DBT engine. The execution flows as followed: a source code is loaded into a source code cache. This cache exists so that only the basic block that is being worked is loaded into RAM memory for quicker access. The DBT engine accesses the source code cache and translates the basic block which is then stored into Translation Cache. The code stored into this cache is native code for the target and ready to execute\cite{f.salgadoj.mendesa.tavaresm.ekpanyapong}.
		
	\begin{figure} [H]
		\centering
		\includegraphics[width=0.65\linewidth]{Images/block}
		\caption{Dynamic Binary Translation architectural model.}
		\label{fig:block}
	\end{figure}


	\section{Resources}
	
		\par For the concretization of this project, there will be used some hardware and software. These are presented next.

		\subsection{Hardware}
		
			\par Here is described the hardware used during the project. All of it was chosen for availability reasons. 

			\paragraph{SmartFusion2 Advanced Development Kit}
			
			\par Microsemi's SmartFusion2 Advanced Development Kit offers a full featured device SmartFusion2 system-on-chip FPGA. This device inherently integrates reliable flash-based FPGA fabric, a Cortex-M3 processor, digital signal processing (DSP) blocks, static random-access memory (SRAM), embedded nonvolatile memory (eNVM), and industry-required high-performance communication interfaces‚Äîall on a single chip \cite{microsemi}. 
			\par This device is used to run the generated sources files so its veracity is verified. 
			
			\begin{figure} [H]
				\centering
				\includegraphics[width=0.5\linewidth]{Images/microsemi}
				\caption{SmartFusion2 Advanced Development Kit.}
				\label{fig:microsemi}
			\end{figure}

		\paragraph{Debugger} The debugger is used to communicate with the device and receive important information about the execution. It has a JTAG interface to interact with the processor and USB to interact with the computer, and supports all ARM 7/9/11, Cortex. In this project it is used the J-Link Segger. 
		
			\begin{figure} [H]
				\centering
				\includegraphics[width=0.3\linewidth]{Images/jlink}
				\caption{Segger J-Link.}
				\label{fig:jlink}
			\end{figure}

		\subsection{Software}
		
		\par The software used in this project was available to download by the developers in internet. 
		
			\paragraph{Eclipse}
			
			\par Eclipse Integrated Developing Environment (IDE) has first developed to program JAVA applications, but its plugins system provides the programming in various languages. This will be used to write the EL script, the elaborations and to generate code.

			\begin{figure} [H]
				\centering
				\includegraphics[width=0.3\linewidth]{Images/eclipse}
				\caption{Eclipse logo.}
				\label{fig:eclipse}
			\end{figure}

			\paragraph{Understand} This software is used to perform the code analysis. The source files are used to create dependences graphs between modules. Is used to validate the code refactoring. 
			
			\begin{figure} [H]
				\centering
				\includegraphics[width=0.3\linewidth]{Images/understand}
				\caption{Understand logo.}
				\label{fig:understand}
			\end{figure}
			
			\paragraph{IAR Workbench} IAR Worksbench is an IDE used to program many platforms. This chosen platform is the ARM based. This software was used to compile the source code and validate the code generation.
			
			\begin{figure} [H]
				\centering
				\includegraphics[width=0.2\linewidth]{Images/iar.jpg}
				\caption{IAR logo.}
				\label{fig:iar}
			\end{figure}

	\section{Implementation Plan}
	
	\par The first task is the study of the dynamic binary translator to get more familiar with the algorithm and completely understand it and its characteristics. The group's objective is to model the code generation, so this part will be studied more deeply.
	\par The second task is the study of the EL framework, where the reference architecture will be implemented following the SCA method.
	\par The third task is the implementation of the reference architecture in the framework and the code refactoring so it will fit the model. 
	\par The fourth task is writing the correspondent EL scripts, annotate the source code and write the elaborations. This will make the code configurable.
	\par It will also be necessary to prepare all the presentations, reports and poster in the project domain.

	\par DIAGRAMA DE GANTT AQUI

%END ANALYSIS CHAPTER
%-------------------------------------------
%START DESIGN CHAPTER

\chapter{Design}

	\par In this section the dynamic binary translator program is analyzed at detail. Then, the reference architecture is constructed in order to allow the systems configuration. 
	\par The dependencies graph will be generated using the Understand software. After this analysis will be decided if the code needs to be refactored in order to be in accordance with the model. 
	
	\section{Code Analysis}
	
	\par The primary source files assigned to the group were not written following a reference architecture. So, the first task is to understand how to code should be organized to be modular. This means that is necessary to identify components, services and references and how do they connect to each other.
	\par The first step is to analyze the \texttt{main} file. It is created an object of the \texttt{DBTEngine} type and the code size is passed as argument to the initialization method. Hereupon is only necessary to run the translator.
	\par To start the translation, there must be code into translation cache. If the source PC does not have a Translation Cache entry, a new entry in Translation Cache is added. Then, the entry location is saved as "next to execute" and a prolog is generated. The prolog pushes all the necessary registers and the Link Register (LR) to stack. After the prolog generation, the code cache is accessed and the next instruction is fetched. 
	\par Then the decoding stage starts and the raw code is treated in order to get the opcode and operands of the fetched instruction. In the end of decode, it is pointed to the next instruction and the target code is generated. It is important to note that one decoded instruction may result in many more target instructions due to ISA incompatibility. 
	\par At this point, if the instruction is a control flow instruction, the algorithm fetches another instruction, decodes it and generates the raw binary for the target again. If not, the epilog is generated and the used registers as well as the PC are poped from stack. After epilog the code is executed and goes to the begin of the algorithm.
	\par This situation happens when the source PC does not have a Translation Cache entry. When this entry exists, the code address is accessed and set as "next to execute", then executed. The flowchart for this algorithm is presented on figure \ref{fig:flowchart-codeanalysis}.
	
	\begin{figure} [H]
		\centering
		\includegraphics[width=0.5\linewidth]{Images/flow-codeanalysis}
		\caption{Translation algorithm.}
		\label{fig:flowchart-codeanalysis}
	\end{figure}	
	
	\par With this analysis it was possible to identify all the necessary components and its interfaces that will be later exposed in the reference architecture and to verify that the primary code needed to be refactored.

	\par The code was also analyzed using the Understand software to prove that the refactor is needed so the code is in accordance with the reference architecture. The resulting graph is presented in figure \ref{fig:understand1}.
	
	\begin{figure} [H]
		\centering
		\includegraphics[width=0.7\linewidth]{Images/refactor.jpg}
		\caption{First analysis done using the Understand software.}
		\label{fig:understand1}
	\end{figure}

	\section{Code Refactoring}
	
	\paragraph{main.cpp}
	
	\paragraph{CBuffer.cpp}
	
	\paragraph{CBuffer.h}
	
	\paragraph{DBTEngine.cpp}
	
	\paragraph{DBTEngine.h}
	
	\paragraph{SourceArch\_8051.cpp}
	
	\paragraph{SourceArch\_8051.h}
	
	\paragraph{SourceArchitecture.cpp}
	
	\paragraph{SourceArchitecture.h}
	
	\paragraph{TargetArch\_CortexM3.cpp}
	
	\paragraph{TargetArch\_CortexM3.h}
	
	\paragraph{TargetArchitecture.cpp}
	
	\paragraph{TargetArchitecture.h}
	
	\paragraph{TransBuffer.cpp}
	
	\paragraph{TransBuffer.h}
	
	\paragraph{Translator.cpp}
	
	\paragraph{Translator.h}
	
	\paragraph{Translator8051.cpp}
	
	\paragraph{Translator8051.h}
	
	\paragraph{types.h}
		
	\section{Code Generation}
	
	\newpage
	
	\section{Reference Architecture}
	
	\par This section explains each of the reference architecture's component and its properties and interfaces. The name notation used indicates that all the references are started with \texttt{r\_} and all the services start with \texttt{s\_}.
	\par The symbols notation is show in figure \ref{fig:caption}.
	
	\begin{figure} [H]
		\centering
		\includegraphics[width=0.1\linewidth]{Images/arch-ref/caption}
		\caption{Symbols used in the reference architecture model.}
		\label{fig:caption}
	\end{figure}

	
		\subsection{DBT}
		
		\par The composite \texttt{DBT} includes all the other components and composites of the dynamic binary translator reference architecture. It references one service of \texttt{DBTEngine} -- \texttt{r\_Engine} -- and two references \texttt{r\_MemSizes} of the service \texttt{s\_MemSizes} of the architecture components. This top level also has one property called \texttt{measure} which is a boolean and activates/deactivates functions to measure the number of cycles that the program executes.
		
		\begin{figure} [H]
			\centering
			\includegraphics[width=1\linewidth]{Images/arch-ref/ref-arch}
			\caption{Reference Architecture of a dynamic binary translator.}
			\label{fig:ref-arch}
		\end{figure}	
	
		\subsection{SourceCluster}
		
		\par The composite \texttt{SourceCluster} includes two components for source architecture and decoder -- \texttt{SourceArch} and \texttt{Decoder} -- and one composite for the source environment -- \texttt{SourceEnv}. It has no services, references or properties.
		
		\begin{figure} [H]
			\centering
			\includegraphics[width=0.6\linewidth]{Images/arch-ref/SourceCluster}
			\caption{SourceCluster composite.}
			\label{fig:SourceCluster}
		\end{figure}
		
			\subsubsection{SourceArch}
			
			The component \texttt{SourceArch} contains the necessary information about the source architecture. It only offers services -- \texttt{s\_MemSizes} that include the external, internal and data memory sizes as well the heap and stack sizes, \texttt{s\_Registers} that informs about the architecture registers and \texttt{r\_ISA} that includes the functions to get the word size, get the PC size and get the number of bits of the opcode. It does not contains properties.
			
			\begin{figure} [H]
				\centering
				\includegraphics[width=0.25\linewidth]{Images/arch-ref/SourceArch}
				\caption{SourceArch component.}
				\label{fig:SourceArch}
			\end{figure}
		
			\subsubsection{SourceEnv}
			
			\par The composite \texttt{SourceEnv} has one service -- \texttt{s\_SrcEnv} that is used to get and set the PC and reset the environment. It does not has references or properties.
			
			\begin{figure} [H]
				\centering
				\includegraphics[width=0.5\linewidth]{Images/arch-ref/SourceEnv}
				\caption{SourceEnv composite.}
				\label{fig:SourceEnv}
			\end{figure}
		
				\subsubsubsection{DataMemory}
				
				\par \texttt{DataMemory} offers one service -- \texttt{r\_DMem} that allows the other components to read and write into data memory -- and one reference to the \texttt{s\_MemSizes} service from \texttt{SourceArch}. It has no properties.
		
				\begin{figure} [H]
					\centering
					\includegraphics[width=0.3\linewidth]{Images/arch-ref/DataMemory}
					\caption{DataMemory component.}
					\label{fig:DataMemory}
				\end{figure}
		
			\subsubsection{Decoder}
			
			\par The component \texttt{Decoder} has six references -- \texttt{r\_ISA} to get the word and PC size and the number of bits of the opcode of the \texttt{SourceArch}, \texttt{r\_Registers} to get the register from \texttt{SourceArch}, \texttt{r\_SrcEnv} to get and set PC, \texttt{r\_CCache} to access the code stored into \texttt{CodeCache}, \texttt{r\_EngineState} from \texttt{DBTEngine} to access the pointers \texttt{eoBB} (end of Basic Block) and \texttt{EoExec} (end of Execution) and \texttt{r\_Generate} to call the functions provided by the \texttt{Generator} -- and one service -- \texttt{s\_Decode} that offers the decoding functions. It has one property \texttt{srcCodeTracing} to let the user decide if he wants to print the decoded instruction in serial port. This can be used as debug. 
			
			\begin{figure} [H]
				\centering
				\includegraphics[width=0.45\linewidth]{Images/arch-ref/Decoder}
				\caption{Decoder component.}
				\label{fig:Decoder}
			\end{figure}			
		
		
		\subsection{TargetCluster}
		
		\par The composite \texttt{TargetCluster} has two components -- \texttt{Generator} and \texttt{TragetArch}. It does not contains services, references or properties.
		
		\begin{figure} [H]
			\centering
			\includegraphics[width=0.6\linewidth]{Images/arch-ref/TargetCluster}
			\caption{TargetCluster composite.}
			\label{fig:TargetCluster}
		\end{figure}
		
			\subsubsection{TargetArch}
			
			\par The \texttt{TargetArch} component includes the three services from target architecture -- \texttt{s\_ISA} to get word and PC size and to get number of bits from opcode, \texttt{s\_Registers} and \texttt{s\_MemSizes} the size of the memories, heap and stack. No properties and references exist in this component.
			
			\begin{figure} [H]
				\centering
				\includegraphics[width=0.25\linewidth]{Images/arch-ref/TargetArch}
				\caption{TargetArch component.}
				\label{fig:TargetArch}
			\end{figure}
		
			\subsubsection{Generator}
			
			\par The \texttt{Generator} component is responsible for the code generation for target architecture. It has seven references -- \texttt{r\_DMem} to read from data memory, \texttt{r\_SrcEnv} to access PC, \texttt{r\_SrcRegisters} to get the registers from source architecture, \texttt{r\_TrgRegisters} to get the registers from target architecture, \texttt{r\_TCache} to store the generated instructions in Translation Cache, \texttt{r\_EngineState} to access the \texttt{eoBB} (end of Basic Block) and \texttt{eoExec} (end of execution) pointers and \texttt{r\_ISA} to get word and PC size as well as the number of bits from the opcode -- and one service -- \texttt{s\_Generate} is responsible for code generation. It also contains two properties -- \texttt{trgCodeTracing} to let the user decide if he wants to print the generated instructions in serial port and \texttt{optimizations} to activate the code generation optimizations.  
			
			\begin{figure} [H]
				\centering
				\includegraphics[width=0.35\linewidth]{Images/arch-ref/Generator}
				\caption{Generator component.}
				\label{fig:Generator}
			\end{figure}
			
		\subsection{CodeCache}
		
		\par The \texttt{CodeCache} stores the code to be translated. It has one reference -- \texttt{r\_ISA} to get word and PC size as well as the number of bits from the opcode -- and one service -- \texttt{s\_CCache} to provide the fetch and the load of instructions, add tags and get last and current translation address. The property \texttt{CCache\_Size} lets the user configure the cache size. 
		
		\begin{figure} [H]
			\centering
			\includegraphics[width=0.3\linewidth]{Images/arch-ref/CodeCache}
			\caption{CodeCache component.}
			\label{fig:CodeCache}
		\end{figure}
		
		\subsection{TranslationCache}
		
		\par The \texttt{TranslationCache} stores the translated code to be executed. It has one reference -- \texttt{r\_ISA} to get word and PC size as well as the number of bits from the opcode -- and one service -- \texttt{s\_TCache} to store the translated code, add tags and get last and current translation address. The property \texttt{CCache\_Size} lets the user configure the cache size. 
		
		\begin{figure} [H]
			\centering
			\includegraphics[width=0.3\linewidth]{Images/arch-ref/TranslationCache}
			\caption{TranslationCache component.}
			\label{fig:TranslationCache}
		\end{figure}
		
		\subsection{DBTEngine}
		
		\par The composite \texttt{DBTEngine} contains the \texttt{Translator} and the \texttt{Executor} components. It references four services -- \texttt{r\_Translate} connected to a service from \texttt{Translator}, \texttt{s\_SrcEnv} that is used to get and set the PC and reset the environment, \texttt{s\_CCache} to fetch instructions, \texttt{r\_Execute} to bind to service from \texttt{Executor} and \texttt{r\_TCache} to access the translated code -- and three services -- \texttt{s\_Engine} to initialize and start the program, \texttt{s\_CurrBBExec} that points to the basic block being executed and \texttt{s\_EngineState} to access the pointers \texttt{eoBB} (end of Basic Block) and \texttt{EoExec} (end of Execution). It does not contains properties.
		
		\begin{figure} [H]
			\centering
			\includegraphics[width=0.7\linewidth]{Images/arch-ref/DBTEngine}
			\caption{DBTEngine composite.}
			\label{fig:DBTEngine}
		\end{figure}
		
			\subsubsection{Translate}
				
			\begin{figure} [H]
				\centering
				\includegraphics[width=0.3\linewidth]{Images/arch-ref/Translator}
				\caption{Translator component.}
				\label{fig:Translator}
			\end{figure}
			
			\subsubsection{Execute}

			\begin{figure} [H]
				\centering
				\includegraphics[width=0.3\linewidth]{Images/arch-ref/Executor}
				\caption{Executor component.}
				\label{fig:Executor}
			\end{figure}
			
		\subsection{Interfaces}

			\paragraph{i\_ISA}
			
			\begin{lstlisting}
			interface i_ISA {
				getWordSize	
				PCSize
				nBitsOpcode
			}
			\end{lstlisting} 
			
			\paragraph{i\_MemSizes}	
			
			\begin{lstlisting}
			interface i_MemSizes{
				xDataMemSize 	
				DataMemSize 	
				MemSize			
				HeapSize			
				StackSize		
			}
			\end{lstlisting} 	

			\paragraph{i\_Registers}
			
			\paragraph{i\_SrcEnv}	
			
			\paragraph{i\_TCache}
			
			\paragraph{i\_DMem}
			
			\paragraph{i\_Decode}
			
			\paragraph{i\_Generate}
			
			\paragraph{i\_Translate}

			\paragraph{i\_CurrBBExec}
			
			\paragraph{i\_Execute}
			
			\paragraph{i\_Engine}
			
			\paragraph{i\_EngineState}				

	
	\section{Test Plans}
	
%END DESIGN CHAPTER
%-------------------------------------------
%START IMPLEMENTATION CHAPTER

\chapter{Implementation Phase}

	\section{Elaboration Language Script}
	
	\par Explicar todo o processo para se escreverem scripts EL
	
	\section{Elaborations}
	
	\par Explicar todo o processo para se escreverem Elabora√ß√µes
	
	\subsection{Annotations}
	
	\par Explicar todo o processo para se anotar
	
	\par Generator
	
	\par falar das outras tamb√©m
	
	\section{Optimizations}
	
	\par Algoritmo
	
	\par Expor resultados
	
	\section{Results}
	


%END CONCEPTION CHAPTER
%-------------------------------------------
%START CONCLUSION CHAPTER

\chapter{Conclusion}

	\section{Future Work} 

%END CONCLUSION CHAPTER
%-------------------------------------------
\newpage
	
\bibliography{mybib}{}
\bibliographystyle{ieeetr}
	
\end{document}