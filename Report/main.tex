\documentclass{report}
\usepackage{color}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\usepackage[margin=1.2in]{geometry}
\usepackage{rotating}
\usepackage[utf8]{inputenc}
\usepackage{multirow}
\usepackage[table,xcdraw]{xcolor}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{tabularx} 
\usepackage{tabulary}
\usepackage{cutwin}
\usepackage{caption}
\usepackage{lipsum}
\usepackage{wrapfig}
\usepackage{color}
\usepackage{eurosym}
%\usepackage{glossaries}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{titlesec}
\usepackage{enumerate}
\usepackage{listings}
%\usepackage{filecontents}
\usepackage{cite}

\newenvironment{abbreviations}{\begin{list}{}{\renewcommand{\makelabel}{\abbrlabel}}}{\end{list}}
\newcommand{\abbrlabel}[1]{\makebox[3cm][l]{\textbf{#1}\ \dotfill}}


\begin{document}
	
\begin{titlepage}
	\centering
	\vspace*{0.5 cm}
	\includegraphics[scale = 0.75]{Images/umee}\\[1.0 cm]
	\textsc{\LARGE University of Minho}\\[2.0 cm]
	\textsc{\Large Project II}\\[0.5 cm]		
	\textsc{\large Integrated Master in Electronics and Computer Engineering}\\[0.5 cm]				% Course Name
	\rule{\linewidth}{0.2 mm} \\[0.4 cm]
		{ \huge \bfseries Final Report} \\
        { \huge \bfseries Modeling for Dynamic Binary Translation \\
			\LARGE \bfseries Code Generation}
		
	\rule{\linewidth}{0.2 mm} \\[1.5 cm]
		
		\begin{minipage}{0.4\textwidth}
			\begin{flushleft} \large
				\emph{Authors:}\\
				Ana Rita Fernandes Martins\\
				David Miguel Parente Almeida
			\end{flushleft}
		\end{minipage}~
		\begin{minipage}{0.4\textwidth}
			\begin{flushright} \large
				\emph{Number:} \\
				64734 \\
				68532
			\end{flushright}
		\end{minipage}\\[2 cm]
		
	{\large Guimarães, \today }\\[2 cm]
		
	\vfill
	
\pagenumbering{gobble}
\end{titlepage}
	
\newpage

%-------------------------------------------
\pagenumbering{roman}  
\tableofcontents
\newpage
%-------------------------------------------	
\listoffigures
\newpage
%-------------------------------------------	
\listoftables
\newpage
%-------------------------------------------	
\section*{Abbreviations}
%please put in alfabetical order
\begin{abbreviations} 
	\item[CC] Condition Codes
	\item[DBT] Dynamic Binary Translation
	\item[DSL] Domain Specific Language
	\item[EL] Elaboration Language
	\item[ISA] Instruction Set Architecture
	\item[XML] eXtensible Markup Language
\end{abbreviations}
\newpage
%-------------------------------------------	
\pagenumbering{arabic}
%START ABSTRACT CHAPTER
\chapter{Abstract}

\par Creating a model for a embedded system provides a time-saving and cost-effective approach to the development of dynamic systems, based on a single model maintained in a tightly integrated software. 
\par Using modern modeling software tools it is possible to design and perform initial validation. It is possible to reduce the risk of errors and shorten development time by performing verification and validation testing throughout the development. Errors and overhead can also be reduced through the use of automatic code generation techniques\cite{modelling-embsys}.
%END ABSTRACT CHAPTER
%-------------------------------------------
%START ANALYSIS CHAPTER
\chapter{Analysis}

	\section{Motivation}
	
	\par Let's write this in the end.

	\section{Objectives}
	
	\par The objectives of this work are:
	\begin{itemize}
		\item Identifying the modules for the reference architecture;
		\item Modeling the implementation of a DBT;
		\item etc
	\end{itemize}

	\section{Problem Statement}
	
	\par Modeling is used in order to automate the configuration and generation of the final system. To create a model it is necessary a specialized framework, and the one used in this project was developed together with all the groups in the context of the major in Embedded Systems, consisting on a Domain Specific Language (DSL) which purpose is to model reference architectures and make its respective code generation. 
	\par In this particular case, the modeling framework is used with the objective to model a DBT, in which the source code follows a 8051 Instruction Srt Architecture (ISA) and the translated code is generated for a ARMv7-M ISA.  The reference architecture was agreed by all the groups that are into this project, and this group focus is on the code generation for the target architecture and code optimization.
	
	\begin{figure} [h]
		\centering
		\includegraphics[width=0.7\linewidth]{Images/DSL_use_cases}
		\caption{Compilation phases.}
		\label{fig:compiler-sequence}
	\end{figure}

	\section{Modeling Languages}
	%START > WIKIPEDIA
	\par A modeling language is any artificial language that can be used to express information or knowledge or systems in a structure that is defined by a consistent set of rules. The rules are used for interpretation of the meaning of components in the structure.
	
	\par A modeling language can be graphical or textual.[1]
	
	Graphical modeling languages use a diagram technique with named symbols that represent concepts and lines that connect the symbols and represent relationships and various other graphical notation to represent constraints.
	Textual modeling languages may use standardized keywords accompanied by parameters or natural language terms and phrases to make computer-interpretable expressions.
	An example of a graphical modeling language and a corresponding textual modeling language is EXPRESS.
	
	Not all modeling languages are executable, and for those that are, the use of them doesn't necessarily mean that programmers are no longer required. On the contrary, executable modeling languages are intended to amplify the productivity of skilled programmers, so that they can address more challenging problems, such as parallel computing and distributed systems.
	
	A large number of modeling languages appear in the literature.
	%END
		
		\subsection{Domain Specific Languages}
		
		\par DSL are programming languages, commonly with a small set of expressions, with the objective of abstracting and simplifying the code written for a specific case. So, these languages are useful just when used in that specific situation. Tough they may look limited at a first glance, they may have all the necessary resources to write code for a determined domain.
		\par The usage of these languages should be simple enough in a way that the model is be the biggest effort done. A model should also be translated into code very intuitively by the user. It is important to note that the user is not always a designer: a DSL should be clear at the point that someone who is not used to programming languages could create its script without a lot of effort. The simplicity is pointed as a advantage, but there are disadvantages too: creating a framework like this requires a lot of technical skills and knowledge, and the development is very time consuming.
		\par To write a DSL it is necessary to gather all the requirements to avoid subjectiveness and to specify all the semantics. Then, it is written a set of grammatic rules that check the desired operation of the language. It is also important to implement software capable of validate the code, type checking and scoping.
		\par After writing all of this software, it is necessary to implement engines that provide code generation. If the code generation is done nicely, the resulting behavioral model is correct.
		
		\subsection{Service Component Architecture}
		%WRITE ABOUT SCA HERE
		\par 
		
		\paragraph{Elaboration Language Context} EL is based on the SCA. Next it is presented every element that can be used and a brief description.
		
			\subparagraph{Composite} A composite is a set of components. These can be used to represent another components or a reference architecture.
		
			\subparagraph{Component} An entity that provides or references services. 
		
			\subparagraph{Property} Variables that can be defined inside the component and that store its characteristics. 
		
			\subparagraph{Interface} A list of functions that describe a service or reference.
		
			\subparagraph{Service} Set of operations associated to a component are characterized by an interface. 
		
			\subparagraph{Reference} A service that is consumed by a component. Also characterized by an interface.
		
			\subparagraph{Wire} A bound created between a reference and a service defined by the same interface.
		
			\subparagraph{Implementation} Code block implemented in a programming language.
		
		\subsection{Elaboration Language}
		
		\par Elaboration Language (EL) was the DSL developed by a group of students to create models, and was written using the Eclipse frameworks Xtext and Xtend. Xtext is necessary for specifying the grammar and all the other features were written using Xtend. 
		\par EL follows the Service Component Architecture specification in which everything is composed by components. The components are related through services and references to that services. 
		\par It is necessary to follow a work flow when using this DSL to create the necessary artifacts. Next the correct work flow is explained.

			\subsubsection{Work Flow}
		
			\par To develop and use a reference architecture there must be followed a work flow, composed by four steps: modeling, elaboration, configuration and generation. Each step provides the artifacts necessary for the subjacent step.
			
			\par ADD IMAGE OF WORK FLOW HERE
		
			\paragraph{Modeling} The first step consists in designing the reference architecture and, after that, writing the respective EL scripts. In some cases it is necessary to make code refactoring to keep the code in concordance with the model. It is also necessary to annotate the source files so the elaborations can replace these same annotations for literal values or expressions.

			\paragraph{Elaboration} In this step are constructed Java classes to alter the code with annotations provided by the user. After the system modeling and writing all the elaboration, it is created a Java program called \textbf{Elaborator}. This program understands the complete model.

			\paragraph{Configuration} At compilation time there are generated XML files with the configuration of the reference architecture components. The User can alter these files and by that configure properties values, arrays sizes ou change which elaboration will modify the source code.

			\paragraph{Generation} After completing all the steps above, the User can execute the Elaborator and generate the new source code. The Elaborator uses all the elaborations necessary to create the code.
			
			\subsubsection{Syntax and Semantics}

			\subsubsection{Use Cases}

			\subsubsection{Example}

	\section{Dynamic Binary Translation}
	\par Binary translation is the process of converting code for one ISA architecture to code for another. There are two types of binary translation: static and dynamic. The main difference between the two approaches is that the static translation translates the entire program before the execution and dynamic translation translates code on demand. This allows the dynamic binary translation (DBT) to deal with challenges that static binary translation do not suffice \cite{b.hawkingsb.demskyd.brueningq.zhao2015}. 
	\par In this project was used a dynamic binary translation to create the model. It translates one basic block at a time and then executes it. The translated code, as well as the source code, is cached so if one basic block is stored into the translation cache, the cache returns an hit and it is not necessary to translate it again. 
	\par In this program, it was used the Intel MCS-51, also known as 8051, as the source architecture and the ARMv7-M as the target architecture. After the code refactoring, it is possible to change the source and target architecture. Although, the translation algorithm will need to be rewritten to adapt to the target architecture needs.
	
		\subsection{Source Architecture: Intel MCS-51}
		
		\par The Intel MCS-51, also known as 8051, is part of a family of 8-bit microcontrollers family developed by Intel in the '80s. It is known for being ease of programming so it is used in large scale for small projects and to instruct students. By being a Complex Instruction Set Computer (CISC) microcontroller, it offers a large set of instructions. These characteristics make it the most popular microcontroller.
		\par The 8051 only offers one memory, divided into two separated addressing spaces to data and programs. In the data memory, the inferior block is divided into three parts: the registers bank, the bit addressable area and the draft area.
		\par The Control Processing Unit (CPU) Special Function Registers (SFR) , with exception of the Program Counter (PC), are allocated into the superior part of the intern data memory.  They are:
		\begin{itemize}
			\item ACC - Acumulator.
			\item B - Used as source and target register to division and multiplication operations.
			\item Stack Pointer (SP) - Pointer to the CPU stack.
			\item Data Pointer (DPTR) - 16-bits register used to address the external data memory. Uses two bytes, the DPL (Data Pointer Low) and DPH (Data Pointer High).
			\item P0, P1, P2, P3 - Used to latch the I/o ports.
			\item Serial Data Buffer (SBUF) - Use to transmission and reception in the serial port.
			\item Program Status Word (PSW) - Contains the CPU flags.
			\item Timer Registers - The 8051 offers three timers and each has two 8-bit registers to configure. The Timer 0 uses TH0 and TL0, Timer 1 uses and TH1 and TL1 and Timer 2 uses TH2 and TL2.
			\item Capture Registers (RCAP2H, RCAP2L) - Used by Timer 2 for the capture mode.
			\item Control Registers - IP, IE, TMOD, RCON, SCON, PCON are control resisters used by the interruption system from serial port and timing sections. 
		\end{itemize}
		
		\par It is important to note that at the time, the translation algorithm only provides a emulation of the ACC, B, SP and DPTR registers.
		\par The 8051 offers five groups of instructions: arithmetic, branch, data transfer, logic and bit-oriented. Arithmetic instructions perform several tasks such as addition, subtraction, division and multiplication. Branch instructions can perform conditional and unconditional jumps. The main difference between them is that conditional jumps rely on the condition codes to verify if the branch is taken or not. Data transfer instructions move the content of one register to another. Logic instructions perform logic operations upon corresponding bits of two registers. Bit-oriented instructions are logic operations perform upon single bits\cite{mikroelektronika}.
		\par The instructions size and format vary from 1 to 3 bytes to achieve the desired output. Even the same operation may vary in instruction size depending on the operands. Looking at the addition operation (ADD) case, when it is desired to add an immediate value to the accumulator (ADD A, \#immediate), 2 bytes are used. When it is desired to add the content of a register to the accumulator (ADD A, Rn), only 1 byte is used. This also means that the PC will be computed differently in accordance with the instruction size.
		
		\subsection{Target Architecture: ARMv7-M}
		
		\par The ARM Cortex-M is a family of 32-bit Reduced Instruction Set Computer (RISC) microcontrollers. The nucleon used in this project is the Cortex-M3.
		\par Cortex-M3 follows the ARMv7-M architecture and has support to Thumb and Thumb-2 instructions. It incorporates a three stage pipeline with branch predictor, a Nested Vectored Interrupt Controller (NVIC) 
		
			\subsubsection{Thumb-2}
		
		
		\subsection{Application Scenario}

	\section{Resources}

		\subsection{Hardware}

			\paragraph{SmartFusion2 Advanced Development Kit}
			
			site: http://www.microsemi.com/products/fpga-soc/design-resources/dev-kits/smartfusion2/smartfusion2-advanced-development-kit
			
			\par Microsemi's SmartFusion®2 Advanced Development Kit offers a full featured 150K LE device SmartFusion2 system-on-chip (SoC) FPGA. This 150K LE device inherently integrates reliable flash-based FPGA fabric, a 166 MHz Cortex™-M3 processor, advanced data security features, digital signal processing (DSP) blocks, static random-access memory (SRAM), embedded nonvolatile memory (eNVM), and industry-required high-performance communication interfaces—all on a single chip. This device also supports all the data security features available in SmartFusion2 devices.
			
			\par The Advanced Development Kit board has numerous standard and advanced peripherals such as: PCIe®x4 edge connector, two FMC connectors for using many off the shelf daughter cards, USB, Philips inter-integrated circuit (I2C), two gigabit Ethernet ports, serial peripheral interface (SPI), and UART. A high precision operational amplifier circuitry on the board helps to measure core power consumption by the device.
			
			\par The SmartFusion2 SoC FPGA memory management system is supported by 1 Giga Byte (GB) of on-board double data rate3 (DDR3) memory and 2 Giga Bit (Gb) SPI flash—1Gb connected to the Microcontroller Subsystem (MSS) and 1Gb connected to the FPGA fabric. The serializer and deserializer (SERDES) blocks can be accessed through the peripheral component interconnect express (PCIe) edge connector or high speed sub-miniature push-on (SMA) connectors or through on-board FPGA mezzanine card (FMC) connector.
			
			\par Kit has programming hardware implemented on-board and does not need an external FlashPro hardware for programming.
			
			\paragraph{Zybo}

		\subsection{Software}

			\paragraph{Understand}

			\paragraph{IAR}

	\section{Block Diagram}

	\section{Implementation Plan}

%END ANALYSIS CHAPTER
%-------------------------------------------
%START DESIGN CHAPTER

\chapter{Design}

	\section{Reference Architecture}
	
	\section{Code Generation}
	
	\section{Test Plans}
	
%END DESIGN CHAPTER
%-------------------------------------------
%START IMPLEMENTATION CHAPTER

\chapter{Implementation Phase}

	\section{Code Refactoring}
	
	\section{Optimizations}
	
	\section{Elaborations}
	
	\section{Elaboration Language Script}

%END CONCEPTION CHAPTER
%-------------------------------------------
%START CONCLUSION CHAPTER

\chapter{Conclusion}

	\section{Future Work} 

%END CONCLUSION CHAPTER
%-------------------------------------------
\newpage
	
\bibliography{mybib}{}
\bibliographystyle{ieeetr}
	
\end{document}